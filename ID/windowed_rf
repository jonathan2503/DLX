library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_unsigned.all;
use IEEE.numeric_std.all;
use WORK.log_function.all;




entity windowed_rf is
generic (M: natural := 8; --number of global
		 N: natural := 8; --number of in/out/local
         F: natural := 4;	--number of windows
		 NBIT : natural := 64);

 port ( 
	 CLK: 		IN std_logic;
     RESET: 	IN std_logic;
	 ENABLE: 	IN std_logic;
	 RD1: 		IN std_logic;
	 RD2: 		IN std_logic;
	 WR: 		IN std_logic;
	 ADD_WR: 	IN std_logic_vector(log2(N * 3 + M)-1 downto 0); 
	 ADD_RD1: 	IN std_logic_vector(log2(N * 3 + M)-1 downto 0);
	 ADD_RD2: 	IN std_logic_vector(log2(N * 3 + M)-1 downto 0);
	 DATAIN: 	IN std_logic_vector(NBIT-1 downto 0);
     OUT1: 		OUT std_logic_vector(NBIT-1  downto 0);
	 OUT2: 		OUT std_logic_vector(NBIT-1  downto 0);
	
	CALL:		IN std_logic;
	RETURN_S:   IN std_logic;
	FILL:	OUT std_logic;
	SPILL: OUT std_logic);
end windowed_rf;


architecture A of windowed_rf is
	
	TYPE STATE IS (WORKING,MEMORY);
	SIGNAL CURRSTATE,NEXTSTATE: STATE;
        -- suggested structures
    subtype REG_ADDR is natural range 0 to (N *2 *F)-1;  -- only for in/out/locals
	subtype REG_ADDR_CONST is natural range 0 to M-1;  -- only constants

	type REG_ARRAY is array(REG_ADDR) of std_logic_vector(NBIT-1 downto 0);
	type REG_ARRAY_CONST is array(REG_ADDR_CONST) of std_logic_vector(NBIT-1 downto 0);
	 
	signal REGISTERS : REG_ARRAY; 
	signal REGISTERS_CONST : REG_ARRAY_CONST; 	
	
	signal SWP, CWP: UNSIGNED(log2(2*N*F) -1 downto 0);-- puntatori alla prima e all'ultima subroutine chiamata nel register file
	signal CANSAVE, CANRESTORE: natural; -- if swp o cwp hanno raggiunto la fine, evitano un ulteriore check
	signal COUNTER_FILL, COUNTER_SPILL : natural;
	
begin 

--OVERALL STRUCTURE OF REG_ARRAY_CONST IS:

--GLOBAL
--IN/OUT
--LOCAL
--IN/OUT
--LOCAL
--IN/OUT
--
--LOCAL

--GLOBALLY M +(N*2)*F REGISTERS
--PYISICALLY THE LAST REGISTER IS A LOCAL REGISTER SUCH THAT A CIRCULAR BUFFER IS IMPLEMENTABLE, IF IT WAS A IN/OUT REGISTER IT WOULD CAUSE A GREAT MESS

--GLOBAL REGISTERS AND IN/LOC/OUT REGISTERS ARE DEFINED USING TWO DIFFERENT TYPES
--ADDRESSES LOWER THAN M ARE ALWAYS ADDRESSED TO THE GLOBAL REGISTERS WHILE THE GREATEST ONES ARE ADDRESSED TO THE IN/LOC/OUT REGISTERS APPLYING PROPERLY THE WINDOW THROUGH CWP


PROCESS(CLK)
BEGIN
IF (RISING_EDGE(CLK)) THEN

	--SET EVERYTHING TO THE RESET VALUE
	IF (RESET='1') THEN

		FOR I IN 0 TO (N *2 *F)-1 LOOP
			REGISTERS(I) <= (OTHERS => '0');
		END LOOP;

		FOR I IN 0 TO M-1 LOOP
			REGISTERS_CONST(I) <= (OTHERS =>'0');
		END LOOP;

		CWP <= (OTHERS => '0'); --POINTS TO THE IN REGISTERS OF THE NEWEST SUBROUTINES CALLED 
		SWP <= (OTHERS => '0'); --POINTS TO THE IN REGISTERS OF THE OLDEST SUBROUTINES CALLED STILL IN THE RF
		CANSAVE <= 0; --POINTS TO WHICH WINDOW CWP POINTS
		CANRESTORE <= 0; --POINTS TO WHICH WINDOW SWP POINTS
		FILL <= '0';
		SPILL <= '0';
		COUNTER_FILL <= 0;
		COUNTER_SPILL <= 0;

	--MEMORY IS COPYING DATA FROM REGISTER FILE REGISTER BY REGISTER, NO OTHER OPERATIONS CAN BE DONE
	ELSIF (COUNTER_SPILL > 0) THEN
		COUNTER_SPILL <= COUNTER_SPILL - 1;	
		OUT1 <= REGISTERS(COUNTER_SPILL-1);
	 
	--MEMORY IS COPYING DATA TO THE REGISTER FILE REGISTER BY REGISTER, NO OTHER OPERATIONS CAN BE DONE
	ELSIF (COUNTER_FILL > 0) THEN
		COUNTER_FILL <= COUNTER_FILL - 1;	
		REGISTERS(COUNTER_FILL-1)<= DATAIN;
	
	
--CANSAVE AND CANRESTORE WILL FOLLOW THROUGHOUT THE WHOLE PROCESS THE WINDOWS POINTED BY CWP AND SWP
--THE CALL OF A NEW SUBROUTINE IS VALID IFF ENABLE IS SET HIGH. A SPILL IS NECESSARY IFF ((CANSAVE+2) mod F = CANRESTORE) OTHERWISE THE OUT REGISTER OF THE NEW SUBROUTINE WOULD COLLIDE WITH THE IN REGISTER OF THE OLDEST SUBROUTINES. AFTER A SPILL BOTH CWP AND SWP ARE INCREMENTED. IN CASE A SPILL IS NOT NECESSARY ONLY CWP IS INCREMENTED. IN ORDER TO INCREMENT CWP AND SWP SOME CHECKS ARE DONE OVER CANSAVE AND CANRESTORE SUCH THAT THE ROLL-BACK IS IMPLEMENTABLE

	ELSIF (CALL = '1')AND (ENABLE = '1') THEN
	-- IF AN OVERWRITE OF THE IN REGISTERS OF THE OLDEST SUBROUTINE CALLED WOULD OCCUR...
	IF ((CANSAVE+2) mod F = CANRESTORE) THEN 
		IF (CANRESTORE = F-1) THEN --CHECK IF A ROLL-BACK MUST BE IMPLEMENTED
			SWP <= (OTHERS => '0');
		ELSE 
			SWP <=  SWP + 2*N;
		END IF;
		CANRESTORE <= (CANRESTORE +1) MOD F;
		SPILL <= '1'; 
		COUNTER_SPILL <= 2*N; -- so for the next 2N clock cycle SPILL will remain high
	ELSE
		SPILL <= '0';
	END IF;
	
	IF (CANSAVE = F-1) THEN --CHECK IF A ROLL-BACK MUST BE IMPLEMENTED
		CWP <= (OTHERS => '0');
	ELSE
		CWP <= (CWP + 2*N); 
	END IF;

	CANSAVE <= (CANSAVE + 1) MOD F;
	FILL <= '0';


	--THE RETURN FROM A SUBROUTINE IS VALID IFF ENABLE IS SET HIGH. A FILL IS NECESSARY IFF (CANSAVE = CANRESTORE) OTHERWISE DATA ARE WRONG. AFTER A FILL BOTH CWP AND SWP ARE DECREMENTED. IN CASE A FILL IS NOT NECESSARY ONLY CWP IS DECREMENTED. IN ORDER TO DECREMENT CWP AND SWP SOME CHECKS ARE DONE OVER CANSAVE AND CANRESTORE SUCH THAT THE ROLL-BACK IS IMPLEMENTABLE
	ELSIF (RETURN_S = '1') AND (ENABLE = '1') THEN 

	
	IF (CANSAVE = CANRESTORE) THEN
		IF (CANRESTORE=0) THEN --CHECK IF A ROLL-BACK MUST BE IMPLEMENTED
			SWP <= TO_UNSIGNED((N *2 *F)-2*N ,SWP'LENGTH); 
		ELSE
		 	SWP <=  SWP- 2*N;
		END IF;
		CANRESTORE <= (CANRESTORE -1) MOD F;
		FILL <= '1';
		COUNTER_FILL <= 2*N;	-- so for the next 2N clock cycle SFILL will remain high
	ELSE 
		FILL <= '0';
	END IF;
	
	IF (CANSAVE = 0) THEN --CHECK IF A ROLL-BACK MUST BE IMPLEMENTED
		CWP <= TO_UNSIGNED((N *2 *F)-2*N,CWP'LENGTH);
	ELSE
		CWP <= CWP- 2*N;
	END IF;
	CANSAVE <= (CANSAVE - 1) MOD F;
	SPILL <= '0';
	
	ELSIF (ENABLE = '1') THEN

		--CHECKS ON THE ADDRESSES ARE PERFROMED AND BASED ON THEM THE CORRECT REGISTERS ARE ACCESSED
		IF (RD1 = '1') THEN
			IF (UNSIGNED(ADD_RD1) < M) THEN
				OUT1 <= REGISTERS_CONST(TO_INTEGER(UNSIGNED(ADD_RD1)));
			ELSE
				OUT1 <= REGISTERS(TO_INTEGER(UNSIGNED(ADD_RD1)+CWP-M));
			END IF;
		END IF;
		
		IF (RD2 = '1') THEN
			IF (UNSIGNED(ADD_RD2) < M) THEN
				OUT2 <= REGISTERS_CONST(TO_INTEGER(UNSIGNED(ADD_RD2)));
			ELSE 
				OUT2 <= REGISTERS(TO_INTEGER(UNSIGNED(ADD_RD1)+CWP-M));
			END IF;
		END IF;

		IF (WR = '1') THEN
			IF (UNSIGNED(ADD_WR) < M) THEN
				REGISTERS_CONST(TO_INTEGER(UNSIGNED(ADD_WR)))<= DATAIN;
			ELSE 
				REGISTERS(TO_INTEGER(UNSIGNED(ADD_WR)+CWP-M))<= DATAIN;
			END IF;
		END IF;
		FILL <= '0';
		SPILL <= '0';
	ELSE
		FILL <= '0';
		SPILL <= '0';
END IF;
END IF;
END PROCESS;

end A;



configuration CFG_WRF_BEH of windowed_rf is
  for A
  end for;
end configuration;
